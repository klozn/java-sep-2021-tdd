# Operation Jericho (starting point: `5-operation-jericho`)

> This is the big one boys... this is where we say our prayers. First in, last out, MARINES!

Private! High command has assigned you with a special mission. They really liked the permission/feature-based authorization, 
but they want **token-based authentication** instead of HTTP basic authentication!

Are you up for the job? Great!

Let's move Private. Move, move, MOVE!  

## What's wrong with Basic Auth?

Throughout the previous codelabs you have set up a backend which allows for HTTP Basic authentication and permission/feature-based authorization.
- Our Permission/feature-based authorization works nicely!
- Our HTTP Basic authentication... does the job...

Although HTTP Basic authentication works rather well (given a secure TLS/HTTPS connection), it has certain limitations:
1. For each(!) request, the credentials are passed as clear text.
    - The clear text is actually not bad, since we should always send it over TLS/HTTPS.
    - But, it is send for every request, thus it gives a hacker the opportunity to steal the credentials. With other authentication strategies,
    a hacker only has one shot for this. The other requests will contain a session or token instead.
    - Furthermore, your browser will somehow have to keep those credentials in storage as long as you want to remain 'authenticated'. 
2. The back end can not force a log-out (because the concept of a log-in or log-out does not really exist in HTTP Basic Authentication) 

We will look into a different technique, a token-based technique called JSON Web Tokens (JWT)
- The English pronounce it as JOT, but we can act like normal people and just pronounce it as JeWeTe. :)

## JWT Introduction

JSON Web Tokens enables a secure way to transmit data between two parties in the form of a JSON object. It’s an open standard and it’s a popular mechanism for web authentication.

The JWT (JSON web token) is composed of:
1. A **header**
2. A **payload**
3. A **signature**
 
All three parts are individually encoded with Base64 and then concatenated by a dot (`header.payload.signature`):
- For example: 
    ```eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJzZWN1cmUtYXBpIiwiYXVkIjoic2VjdXJlLWFwcCIsInN1YiI6IkdFTk5ZIiwiZXhwIjoxNTcxMzAwNzI3LCJyb2wiOlt7ImF1dGhvcml0eSI6IkdFVF9BUk1ZX0lORk8ifSx7ImF1dGhvcml0eSI6IkxBVU5DSF9OVUtFUyJ9XX0.FjevKY1jAIMWgoyGjdg9M7LRDduTRzsj5Sm_EATSB_9giYqPgY4L2zyKrPsA0xNgspn5Nb-yff4gmvxMdoQVLg```

The JSON Web Token is generated by the backend upon a successful authentication attempt, and then given to the frontend. 
The frontend must then provide, for each protected request, the JSON Web Token to the backend in order to perform. 

### Part 1: Header
The header component of the JWT contains information about how the JWT signature should be computed. The header is a JSON object in the following format:
```
{
  "typ": "JWT",
  "alg": "HS512"
}
```

In this JSON, the value of the "typ" key specifies that the object is a JWT, and the value of the "alg" key specifies which hashing algorithm is being used to create the JWT signature component. 
In this example, the HMAC-SHA512 algorithm is used.

The Header is always (Base64) encoded, e.g. `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9`

### Part 2: Payload
The payload component of the JWT is the data that's stored inside the JWT. These data are coded in **claims**, that is statements about an entity, 
typically the user. Claims are often very useful for enabling **authorization**, in this scenario, claim "rol" defines the different authorities.
```
{
  "iss": "secure-api",
  "aud": "secure-app",
  "sub": "GENNY",
  "exp": 1571300727,
  "rol": [
    {
      "authority": "GET_ARMY_INFO"
    },
    {
      "authority": "LAUNCH_NUKES"
    }
  ]
}
```

The Payload is always (Base64) encoded, e.g. `eyJpc3MiOiJzZWN1cmUtYXBpIiwiYXVkIjoic2VjdXJlLWFwcCIsInN1YiI6IkdFTk5ZIiwiZXhwIjoxNTcxMzAwNzI3LCJyb2wiOlt7ImF1dGhvcml0eSI6IkdFVF9BUk1ZX0lORk8ifSx7ImF1dGhvcml0eSI6IkxBVU5DSF9OVUtFUyJ9XX0`

### Part 3: Signature
The signature gets generated by combining the encoded header and payload together, then hashing the combined result by using a secret key that only server knows.
The signature itself then gets encoded as well, e.g. `FjevKY1jAIMWgoyGjdg9M7LRDduTRzsj5Sm_EATSB_9giYqPgY4L2zyKrPsA0xNgspn5Nb-yff4gmvxMdoQVLg`

### All 3 parts combined into a JSON Web Token
Now that we have created all three components, we can create the JWT. Remembering the `header.payload.signature` structure of the JWT, 
we simply need to combine 3 components (header, payload and signature), with periods (`.`).

**JWT**:
```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJzZWN1cmUtYXBpIiwiYXVkIjoic2VjdXJlLWFwcCIsInN1YiI6IkdFTk5ZIiwiZXhwIjoxNTcxMzAwNzI3LCJyb2wiOlt7ImF1dGhvcml0eSI6IkdFVF9BUk1ZX0lORk8ifSx7ImF1dGhvcml0eSI6IkxBVU5DSF9OVUtFUyJ9XX0.FjevKY1jAIMWgoyGjdg9M7LRDduTRzsj5Sm_EATSB_9giYqPgY4L2zyKrPsA0xNgspn5Nb-yff4gmvxMdoQVLg
```

### Verifying the JWT

Remember how a JWT contains a digital signature that gets generated by the backend by combining the header and the payload? 
For generating a valid signature, a secret key that only the backend (server) knows is used. This means several things:
- Should a malicious user change the header or the payload, the signature is no longer valid.
- If a malicious user changes either header or payload, it needs to create a new, valid signature. But for this the secret key is required, which only the backend has.
- The backend, based on the signature, can quickly validate if a received JWT is a valid token, and one that it created itself. 

So, if malicious users try to modify the values in the payload, they have to recreate the signature and for that purpose, 
they need the secret key which the only server has. 

At the server side, we can easily verify and validate a provided JWT by comparing the signature of the provided JWT 
with a newly computed signature - using the secret key - created from the header and payload part of the provided JWT.

Using JWT, the backend/server can easily verify the **integrity** of the JWT by comparing the digital signatures.

Furthermore, upon creating a JWT, an expiration date (e.g. 1 hour) can be set as part of the payload. Upon receiving a JWT, 
the backend can quickly validate if the received token is already expired

## Implementing JWT

### 1. Add the correct dependencies

To implement JWT authentication (and authorization) in our Java, Spring based, backend, we will have to add a dependency
to the JJWT (Java JWT) library.

Add the following dependencies to `pom.xml` file of module jericho.
```
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>${jsonwebtoken.version}</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>${jsonwebtoken.version}</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>${jsonwebtoken.version}</version>
    <scope>runtime</scope>
</dependency>
```
- Where `${jsonwebtoken.version}` is set to `0.10.7`

Furthermore, we should also have a dependency on `spring-boot-starter-security`. This dependency is already provided.

### 2. Add required constants

We are going to create a class which sole responsibility is to hold some constants. The most important constant in it
is our secret signing key.

> Note: You should never hardcode the JWT signing (secret) key into your application code (we will ignore that for now in this example).
> Instead, in production worthy applications, you should use an environment variable or external .properties file (it should not become part if your Git repository!). 
> Also, the signing key needs to have an appropriate length: For example, the HS512 algorithm needs a key with size at least 512 bytes.
> On https://www.allkeysgenerator.com/ > Encryption Key > 512-bit, you can generate a new signing key.

Create the following class:
```
public final class SecurityConstants {

    public static final String AUTH_LOGIN_URL = "/authenticate";

    public static final String JWT_SECRET = "eShVkYp3s6v9y$B&E)H@McQfTjWnZq4t7w!z%C*F-JaNdRgUkXp2s5u8x/A?D(G+";

    public static final String TOKEN_HEADER = "Authorization";
    public static final String TOKEN_PREFIX = "Bearer ";
    public static final String TOKEN_TYPE = "JWT";
    public static final String TOKEN_ISSUER = "secure-api";
    public static final String TOKEN_AUDIENCE = "secure-app";

    private SecurityConstants() {
        throw new IllegalStateException("Cannot create instance of SecurityConstants (it's a 'static utility' class");
    }
}
```

### 3. Add an Authentication Filter

We will be introducing the concept of a Spring Security Filter.

> Spring Security has a series of servlet filters (a filter chain). When a request reaches the server, it is intercepted by this series of filters.
> The servlet filter code execution of the filter chain keeps skipping filters until the right filter is reached. 
> Once it reaches the right authentication filter based on the authentication mechanism used, it extracts the supplied credentials — most commonly a username and password — from the caller.

Go through the following article, it gives a high-level overview of how Spring Security works and will help you understand what is happening.
- https://dzone.com/articles/spring-security-authentication
    - It is perfectly OK to not understand every detail written in this article!

Done reading the article? Good.

We will be creating our own custom filter for Authenticating a user, called `JwtAuthenticationFilter`:
1. It will attempt to authenticate a user based on the provided credentials
2. Upon successfully authenticating a user, it will generate a JSON Web Token which will be returned in the response to the user.

```
public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

}
```

The `JwtAuthenticationFilter` will have to extend the `UsernamePasswordAuthenticationFilter` class of Spring Security.
- The JavaDoc of UsernamePasswordAuthenticationFilter reads as follows:
``` 
* UsernamePasswordAuthenticationFilter processes an authentication form submission. 
* Login forms must present two parameters to this filter: a username and password. 
* The default parameter names to use are contained in the static fields
  SPRING_SECURITY_FORM_USERNAME_KEY and SPRING_SECURITY_FORM_PASSWORD_KEY

* This filter by default responds to the URL /login. 
```
- Thus, by having such a filter, a call to `HTTP://BASE_URL/login?username=Jimmy&password=12345` should reach this filter (by default).

Make sure your `JwtAuthenticationFilter` is implemented like this:

```
public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    private final AuthenticationManager authenticationManager;

    public JwtAuthenticationFilter(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;

        setFilterProcessesUrl(SecurityConstants.AUTH_LOGIN_URL);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) {
        var username = request.getParameter(UsernamePasswordAuthenticationFilter.SPRING_SECURITY_FORM_USERNAME_KEY);
        var password = request.getParameter(UsernamePasswordAuthenticationFilter.SPRING_SECURITY_FORM_PASSWORD_KEY);

        return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
    }

    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain filterChain, Authentication authentication) {
        var token = Jwts.builder()
                .signWith(Keys.hmacShaKeyFor(SecurityConstants.JWT_SECRET.getBytes()), SignatureAlgorithm.HS512)
                .setHeaderParam("typ", SecurityConstants.TOKEN_TYPE)
                .setIssuer(SecurityConstants.TOKEN_ISSUER)
                .setAudience(SecurityConstants.TOKEN_AUDIENCE)
                .setSubject(authentication.getName())
                .setExpiration(new Date(new Date().getTime() + 3600000)) // 1h
                .claim("rol", authentication.getAuthorities())
                .compact();

        response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + token);
    }
}
```

Let's go through this code step by step.

#### The constructor and AuthenticationManager

```
private final AuthenticationManager authenticationManager;

public JwtAuthenticationFilter(AuthenticationManager authenticationManager) {
    this.authenticationManager = authenticationManager;

    setFilterProcessesUrl(SecurityConstants.AUTH_LOGIN_URL);
}
```

1. We set (through constructor dependency injection) the `AuthenticationManager`
    - In Spring Security, the main strategy interface for authentication is `AuthenticationManager` which has the `authenticate` method.
2. We set the default authentication url (from `/login`) to `/authenticate` (AUTH_LOGIN_URL).

#### The attemptAuthentication method

```
@Override
public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) {
    var username = request.getParameter(UsernamePasswordAuthenticationFilter.SPRING_SECURITY_FORM_USERNAME_KEY);
    var password = request.getParameter(UsernamePasswordAuthenticationFilter.SPRING_SECURITY_FORM_PASSWORD_KEY);

    return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
}
```

1. We extract, from the (HTTP) request, the username and password parameters
    - E.g.: `HTTP://BASE_URL/authenticate?username=Jimmy&password=12345` will extract Jimmy (username) and 12345 (password)
2. We delegate the actual authentication to our `AuthenticationManager`'s `authenticate` method.
    - Remember how we have the `ArmyAuthenticationProvider`? It is given to the `AuthenticationManagerBuilder` in our `SecurityConfig`.
        - An `AuthenticationProvider` is a bit like an `AuthenticationManager` but it has an extra method to allow the caller to query if it supports a given `Authentication` type.
        - Long story short: when calling the `authenticate` method here, we will execute method `authenticate` of `ArmyAuthenticationProvider`.
3. We will return the 'authenticated user' as an `Authentication` object (created in `ArmyAuthenticationProvider`) which contains the credentials and authorities that user has in our system. 

#### The successfulAuthentication method

```
@Override
protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                        FilterChain filterChain, Authentication authentication) {
    var token = Jwts.builder()
            .signWith(Keys.hmacShaKeyFor(SecurityConstants.JWT_SECRET.getBytes()), SignatureAlgorithm.HS512)
            .setHeaderParam("typ", SecurityConstants.TOKEN_TYPE)
            .setIssuer(SecurityConstants.TOKEN_ISSUER)
            .setAudience(SecurityConstants.TOKEN_AUDIENCE)
            .setSubject(authentication.getName())
            .setExpiration(new Date(new Date().getTime() + 3600000)) // 1h
            .claim("rol", authentication.getAuthorities())
            .compact();

    response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + token);
}
```

1. It creates the actual JSON Web Token:
    - The subject (who) is set to the username of the user
    - An expiration is set for the token. This token will be valid for only 1 hour.
    - Custom claim "rol" is set, which contains all the authorities our user has in our system
    - ...
2. At the last line of the method, the actual JSON Web Token is added to the Authorization Header of the request. This is where the client will find its token. It will have to store it locally and use it for every request to our backend.

So far, so good... Authentication is as good as done.
Let's configure our Authorization so that it is compatible with JWT. 

### 4. Add an Authorization Filter

As with authentication, we will use the mechanism of Spring Security Filters to properly configure the authorization using JWT.

We will be creating our own custom filter for Authorizing a user, called `JwtAuthorizationFilter`:
1. For eah request, it will check if a JSON Web Token is provided in the request and if it is a valid token
    - If not, it will not authorize (403) the user to perform the request.
    - If a valid JWT is provided, it will put that authenticated and authorized user in memory (in the security context) for as long as the request is active.
        - (We can get that context (who is the authenticated user?) in all Spring managed beans.)

```
public class JwtAuthorizationFilter  extends BasicAuthenticationFilter {

}
```

Make sure your `JwtAuthorizationFilter` is implemented like this:
```
public class JwtAuthorizationFilter  extends BasicAuthenticationFilter {

    private static final Logger log = LoggerFactory.getLogger(JwtAuthorizationFilter.class);

    public JwtAuthorizationFilter(AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws IOException, ServletException {
        var authentication = getAuthentication(request);
        if (authentication == null) {
            filterChain.doFilter(request, response);
            return;
        }

        SecurityContextHolder.getContext().setAuthentication(authentication);
        filterChain.doFilter(request, response);
    }

    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) {
        var token = request.getHeader(SecurityConstants.TOKEN_HEADER);
        if (!isEmpty(token) && token.startsWith(SecurityConstants.TOKEN_PREFIX)) {
            try {
                var signingKey = SecurityConstants.JWT_SECRET.getBytes();

                var parsedToken = Jwts.parser()
                        .setSigningKey(signingKey)
                        .parseClaimsJws(token.replace("Bearer ", ""));

                var username = parsedToken
                        .getBody()
                        .getSubject();

                ArrayList<LinkedHashMap<String, String>> authoritiesInToken
                        = parsedToken.getBody().get("rol", ArrayList.class);
                var authorities = authoritiesInToken.stream()
                        .map(linkedMap -> linkedMap.get("authority"))
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());

                if (!isEmpty(username)) {
                    return new UsernamePasswordAuthenticationToken(username, null, authorities);
                }
            } catch (ExpiredJwtException exception) {
                log.warn("Request to parse expired JWT : {} failed : {}", token, exception.getMessage());
            } catch (UnsupportedJwtException exception) {
                log.warn("Request to parse unsupported JWT : {} failed : {}", token, exception.getMessage());
            } catch (MalformedJwtException exception) {
                log.warn("Request to parse invalid JWT : {} failed : {}", token, exception.getMessage());
            } catch (SignatureException exception) {
                log.warn("Request to parse JWT with invalid signature : {} failed : {}", token, exception.getMessage());
            } catch (IllegalArgumentException exception) {
                log.warn("Request to parse empty or null JWT : {} failed : {}", token, exception.getMessage());
            }
        }

        return null;
    }
}
```

Hopefully, you understand (high-level) what is happening here in this particular filter.
- If not: ASK!

Do note that `JwtAuthorizationFilter` extends from `BasicAuthenticationFilter`.
- The `Authorization` header has to be used, it should contain the JWT.
    - But, instead of using `Authorization Basic <credentials>` (using the Basic Authentication Scheme) 
    we will use the `Bearer` scheme: `Authorization Bearer <JWT>`
    
The actual code to perform Authentication and Authorization using JWT is implemented.
What is left is to update our `SecurityConfig` class so that it will start using our filters,
thus performing authentication (& authorization) using JWT instead of Basic Authentication.

### 5. Modify SecurityConfig

We need to reconfigure our `HttpSecurity` object as follows:
```
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.cors().and()
            .csrf().disable()
            .authorizeRequests()
            .antMatchers(InformationResource.INFORMATION_RESOURCE_PATH).permitAll()
            .anyRequest().authenticated()
            .and()
            .addFilter(new JwtAuthenticationFilter(authenticationManager()))
            .addFilter(new JwtAuthorizationFilter(authenticationManager()))
            .sessionManagement().sessionCreationPolicy(STATELESS);
}
```

Please notice the following:
1. We enabled Cross Origin Resource Sharing (cors) so you might more easily perform HTTP-requests to your backend
    - https://developer.mozilla.org/nl/docs/Web/HTTP/CORS
2. We permit every call done to our InformationResource controller (`/information`), thus you don't need to be authenticated to be able to do a `GET /information` request.
3. All other requests (thus all requests to `/army`) require authentication.
4. We added our 2 filters.
5. We removed the configuration for the Basic Authentication and our Entry Point class.

### 6. Clean up

Remove your Entry Point class as it is no longer used nor required.

### 7. Manual validation

1. Start your backend, it will run on port `9123`.
2. Perform GET `http://localhost:9123/information`, it should just work...
3. Perform POST `http://localhost:9123/authenticate?username=GENNY&password=RALLY`
    - You should be authenticated, make sure to copy the received JWT token... (in the header)
4. Paste the token in https://jwt.io, inspect its payload.
    - It should look like this:
        ```
          {
            "iss": "secure-api",
            "aud": "secure-app",
            "sub": "GENNY",
            "exp": 1571307789,
            "rol": [
              {
                "authority": "GET_ARMY_INFO"
              },
              {
                "authority": "LAUNCH_NUKES"
              }
            ]
          }
        ```
5. Perform GET `http://localhost:9123/armies/belgium` with the received JWT token
    - Don't forget to use scheme `Bearer` for header `Authorization`: `Authorization Bearer <JWT>`
    - User GENNY has the required authority (GET_ARMY_INFO)
    - You should receive 200 OK with payload:
        ```
        {
            "country": "belgium",
            "numberOfTroops": 2000,
            "xCoordinateOfBase": 15,
            "yCoordinateOfBase": 20
        }
        ```
6. Perform GET `http://localhost:9123/armies/belgium` WITHOUT the received JWT token
    - You should receive 403 FORBIDDEN.
7. Perform GET `http://localhost:9123/armies/nuke` with the received JWT token
    - User GENNY has the required authority (LAUNCH_NUKE)
    - You should receive 200 OK with payload:
        ```
        The world ends. Not with a bang but a whimper
        ``` 
8. Perform POST `http://localhost:9123/armies` (to join the army) with the received JWT token
       - User GENNY does NOT have the required authority (JOIN_ARMY)
       - You should receive 403 FORBIDDEN.

### 8. Run your tests

They will still fail... Check your `RestAssuredTest` class, see how it still is using Basic Authentication...
- Think about what you will need in order to perform valid requests.
- Try to fix your tests (but first, maybe take a look at Password Protection)

### 9. Password Protection

Currently, we are saving our user's passwords as plain text (in our dummy in memory database).
> Which is bad... very bad!

Should you have already forgotten the slides about protecting the passwords of your users, here's a quick reminder before implementing a solution.

#### What is Password Hashing?

Hash algorithms (of which there are many different) are one way functions. They turn any amount of data into a fixed-length "fingerprint" that cannot be reversed. 
They also have the property that if the input changes by even a tiny bit, the resulting hash is completely different (see the example below). 
This is great for protecting passwords, because we want to store passwords in a form that protects them even if the password file (e.g. the database) itself is compromised, 
but at the same time, we need to be able to verify that a user's password is correct. These hash algorithms are made to be secure, not be fast (as the ones in our hash-based data structures)
```
hash("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash("hbllo") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366
hash("waltz") = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542
```

#### Why is Password Hashing not enough?

Due to inventive crackers/hackers, given a hash, the original password can be retrieved by one of the following cracking techniques: 

1. Brute force attacks (Guess the password, hashing each guess, and checking if the guess's hash equals the hash being cracked) 
2. Lookup tables exist (Precomputed hashes and their corresponding plain-text passwords)
3. Rainbow tables exist (Similar to lookup tables but more efficient)

#### Adding a Salt

Salting makes it impossible to use lookup tables and rainbow tables to crack a hash.

Lookup tables and rainbow tables only work because each password is hashed the exact same way. 
If two users have the same password, they'll have the same password hashes. 
We can prevent these attacks by randomizing each hash, so that when the same password is hashed twice, the hashes are not the same.

```
hash("hello")                    = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash("hello" + "QxLUF1bgIAdeQX") = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1
hash("hello" + "bv5PehSMfV11Cd") = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226ab
hash("hello" + "YYLmfY6IehjZMQ") = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007
```

We can randomize the hashes by appending or prepending a random string, called a salt, to the password before hashing. 
As shown in the example above, this makes the same password hash into a completely different string every time. 
To check if a password is correct, we need the salt, so it is usually stored in the user account database along with the hash, or as part of the hash string itself.

The salt does not need to be secret. Just by randomizing the hashes, lookup tables, reverse lookup tables, and rainbow tables become ineffective. 
An attacker won't know in advance what the salt will be, so they can't pre-compute a lookup table or rainbow table. 
If each user's password is hashed with a different salt, the reverse lookup table attack won't work either.

#### Salted Password Hashing

Random long salt + strong hashing algorithm is the right way to securely store passwords.

##### To Store a Password
1. Generate a long random salt.
2. Prepend the salt to the password and hash it with a standard password hashing function.
3. Save both the salt and the hash in the user's database record.

##### To Validate a Password
1. Retrieve the user's salt and hash from the database.
2. Prepend the salt to the given password and hash it using the same hash function.
3. Compare the hash of the given password with the hash from the database. If they match, the password is correct. Otherwise, the password is incorrect.

### Implementing a solution

We will be using Spring Security's `BCryptPasswordEncoder` to encode our passwords before storing them. `BCryptPasswordEncoder`, will automatically use a random salt and append it to the raw password before hashing it.
- Furthermore `BCryptPasswordEncoder` allows us to compare a raw / plain password with an encoded password, to see if they match.

Create a configuration class `PasswordConfig`:
```
@Configuration
public class PasswordConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
```

Then, inject it in the `FakeAuthenticationService`, which, after some refactoring has to look like this:
```
@Service
public class FakeAuthenticationService {

    private final PasswordEncoder passwordEncoder;
    private List<ExternalAuthentication> externalAuthentications;

    @Autowired
    public FakeAuthenticationService(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
        this.externalAuthentications = defaultUsers();
    }

    private ArrayList<ExternalAuthentication> defaultUsers() {
        return newArrayList(
                ExternalAuthentication.externalAuthentication().withUsername("CRIMI").withPassword(passwordEncoder.encode("NAL")).withRoles(newArrayList("PRIVATE")),
                ExternalAuthentication.externalAuthentication().withUsername("MOB").withPassword(passwordEncoder.encode("BOSS")).withRoles(newArrayList("PRIVATE")),
                ExternalAuthentication.externalAuthentication().withUsername("ZWANETTA").withPassword(passwordEncoder.encode("WORST")).withRoles(newArrayList("CIVILIAN")),
                ExternalAuthentication.externalAuthentication().withUsername("JMILLER").withPassword(passwordEncoder.encode("THANKS")).withRoles(newArrayList("PRIVATE")),
                ExternalAuthentication.externalAuthentication().withUsername("UNCLE").withPassword(passwordEncoder.encode("SAM")).withRoles(newArrayList("HUMAN_RELATIONSHIPS")),
                ExternalAuthentication.externalAuthentication().withUsername("GENNY").withPassword(passwordEncoder.encode("RALLY")).withRoles(newArrayList("GENERAL"))
        );
    }

    public ExternalAuthentication getUser(String username, String rawPassword) {
        return externalAuthentications.stream()
                .filter(externalAuthentication -> externalAuthentication.getUsername().equals(username))
                .filter(externalAuthentication -> passwordEncoder.matches(rawPassword, externalAuthentication.getPassword()))
                .findFirst()
                .orElse(null);
    }
}
```

1. Notice how every password is first encoded (random salt, then hashed) before being stored in the dummy database.
    - List `externalAuthentications` will only store protected passwords now.
    - (normally, we don't hard code passwords like this)
2. When calling `getUser` we now use the `matches` method of `PasswordEncoder` to check if a raw / plain-text password 
is equal to its random-salted, hashed variant. 

Restart your backend, everything should still work as before.
- But, no plain-text passwords are kept in memory, only hashed passwords (in List `externalAuthentications`).

#### Solution
Inspect the `solutions` branch for a solution.

### 10. Resources
1. https://jwt.io/
2. https://dzone.com/articles/spring-security-authentication
3. https://spring.io/guides/topicals/spring-security-architecture
4. https://www.baeldung.com/spring-security-authentication-with-a-database (when storing users in a database)
5. https://crackstation.net/hashing-security.htm
6. https://dev.to/keysh/spring-security-with-jwt-3j76
7. https://www.baeldung.com/java-config-spring-security
